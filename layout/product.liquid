<!doctype html>
<html data-wf-page="67977c7d10cee70041b2584e" data-wf-site="67977c7d10cee70041b257de" lang="{{ request.locale.iso_code }}"><head><meta charset="utf-8">
<title>{{ page_title }}</title><meta content="{{ page_description }}" name="description">
<meta content="{{ page_title }}" property="og:title">
<meta content="{{ page_description }}" property="og:description">
<meta content="{{ page_title }}" property="twitter:title">
<meta content="{{ page_description }}" property="twitter:description">
<meta property="og:type" content="website">
<meta content="summary_large_image" name="twitter:card">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta content="Webflow" name="generator">
<link href="{{ 'normalize.css' | asset_url }}" rel="stylesheet" type="text/css">
<link href="{{ 'webflow.css' | asset_url }}" rel="stylesheet" type="text/css">
<link href="{{ 'liquify-testing-template.webflow.css' | asset_url }}" rel="stylesheet" type="text/css">
<script type="text/javascript">! function(o, c) {
        var n = c.documentElement,
          t = " w-mod-";
        n.className += t + "js", ("ontouchstart" in o || o.DocumentTouch && c instanceof DocumentTouch) && (n.className += t + "touch")
      }(window, document);
    </script>
            {% if settings.favicon == blank %}
              <link href="{{ 'favicon.png' | asset_url }}" rel="shortcut icon" type="image/x-icon">
            {% else %}
              <link rel="shortcut icon" type="image/png" href="{{ settings.favicon | img_url: '32x32' }}">
            {% endif %}
        

            {% if settings.apple_touch_icon == blank %}
              <link href="{{ 'webclip.png' | asset_url }}" rel="apple-touch-icon">
            {% else %}
              <link rel="apple-touch-icon" type="image/png" href="{{ settings.apple_touch_icon | img_url: '32x32' }}">
            {% endif %}
        
<!--  Alpine Focus Plugin  -->
<script defer="" src="https://cdn.jsdelivr.net/npm/@alpinejs/focus@3.x.x/dist/cdn.min.js"></script><!--  Alpine JS  -->
<script defer="" src="{{ 'alpinejs3.js' | asset_url }}"></script><script defer="" auto="" min="" src="https://cdn.jsdelivr.net/gh/liquify-pro/core@latest/script.js"></script><link href="{{ canonical_url }}" rel="canonical">
<style>[x-cloak] {
        display: none !important;
      }
      [li-cloak_disabled] {
        display: none !important;
      }
      /* Setup Font and Background Color if Text is selected */
      ::selection {
        color: #fff;
        background: #E91B7F;
      }
      ::-moz-selection {
        color: #fff;
        background: #E91B7F;
      }
    </style><meta name="theme-color" content="#000" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#fff" media="(prefers-color-scheme: dark)">
   
{% if page.metafields.custom.index == false or request.page_type == 'collection' %}
<meta name="robots" content="noindex">
{% endif %}
{% if request.page_type == "page" %}
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "AQON Pure",
  "url": "https://www.aqon-pure.com",
  "logo": "https://cdn.shopify.com/s/files/1/0840/0581/4600/files/logo-aqon-pure__8_1.webp?v=1730709782",
  "address": {
    "@type": "PostalAddress",
    "streetAddress": "Im Erpel 6",
    "addressLocality": "Alsbach-H&auml;hnlein",
    "postalCode": "64665",
    "addressCountry": "DE"
  },
  "contactPoint": {
    "@type": "ContactPoint",
    "telephone": "+49(0) 62 51 / 59 308 - 0",
    "contactType": "customer service"
  },
    "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "{{ settings.reviews }}",
    "reviewCount": "{{ settings.reviews_count }}"
  }
}
</script>
{% endif %}
<script type="application/ld+json">{
        "@context": "https://schema.org",
        "@type": "Product",
        "name": "{{ product.title }}",
        "image": "https:{{ product.featured_image.src | img_url: '1500x1500' }}",
        "description": "{{ product.description | strip_html }}",
        "brand": "{{ product.vendor }}",
        "sku": "{{ product.selected_or_first_available_variant.sku }}",
        "offers": [{% for variant in product.variants %} {
          "@type": "Offer",
          "url": "{{ variant.url }}",
          "priceCurrency": "EUR",
          "price": "{{ variant.price | money }}",
          "priceValidUntil": "{{ 'now' | date: '%s' | plus: 31536000 | date: '%Y-%m-%d' | uri_encode | replace:'+','%20' }}",
          "availability": "{% if variant.available %}https://schema.org/InStock{% else variant.available == false %}https://schema.org/SoldOut{% endif %}",
          "itemCondition": "https://schema.org/NewCondition"
        } {% if forloop.last == false %}, {% endif %} {% endfor %}]
      }
    </script><script type="application/ld+json">{
        "@context": "https://schema.org",
        "@type": "BreadcrumbList",
        "itemListElement": [{
            "@type": "ListItem",
            "position": 1,
            "item": {
              "@id": "{{ shop.url }}",
              "name": "Home"
            }
          },
          {
            "@type": "ListItem",
            "position": 2,
            "item": {
              "@id": "{% if collection.url %}{{ collection.url }}{% else %}{{ product.vendor }}{% endif %}",
              "name": "{% if collection.url %}{{collection.title }}{% else %}{{ product.vendor }}{% endif %}"
            }
          },
          {
            "@type": "ListItem",
            "position": 3,
            "item": {
              "@id": "{{ product.url }}",
              "name": "{{ product.title }}"
            }
          }
        ]
      }
    </script><script type="application/ld+json">{
        "@context": "https://schema.org",
        "@type": "FAQPage",
        "mainEntity": [{% for fa_qs in shop.metaobjects.fa_qs.values %} {
          "@type": "Question",
          "name": "{{ fa_qs.frage }}",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "{{ fa_qs.antwort | metafield_tag | strip_html }}"
          }
        } {% if forloop.last == false %}, {% endif %} {% endfor %}]
      }
    </script><script src="{{ '_helper.js' | asset_url }}" type="text/javascript"></script>{{ content_for_header }}</head>
<body li-page="product">

<div class="page-wrapper">{% render 'global_styles' %}
{% section 'r_header' %}
 {{ content_for_layout }} {% section 'footer' %}
</div><script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=67977c7d10cee70041b257de" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script><script src="{{ 'webflow.js' | asset_url }}" type="text/javascript"></script><script src="{{ 'section-rendering.js' | asset_url }}"></script><script src="https://cdn.jsdelivr.net/npm/swiper@9/swiper-bundle.min.js"></script><script>$(".swiper-container").each(function(index) {
        const thumbsSwiper = new Swiper($(this).find(".swiper.is-product-thumbnail")[0], {
          slidesPerView: "auto",
          rewind: false,
          loopedSlides: 8,
          slideToClickedSlide: true,
          spaceBetween: "4%",
        });
        const swiper = new Swiper($(this).find(".swiper.is-product-gallery")[0], {
          mousewheel: {
            forceToAxis: true
          },
          thumbs: {
            swiper: thumbsSwiper,
            slideThumbActiveClass: "is-active",
          },
          keyboard: {
            enabled: true,
            onlyInViewport: true
          },
          navigation: {
            nextEl: $(this).find(".swiper-next")[0],
            prevEl: $(this).find(".swiper-prev")[0],
          }
        });
      });
    </script><script>document.addEventListener('DOMContentLoaded', function() {
        const productRecommendationsSection = document.querySelector('.product-recommendations');
        const url = productRecommendationsSection.dataset.url;
        fetch(url)
          .then(response => response.text())
          .then(text => {
            const html = document.createElement('div');
            html.innerHTML = text;
            const recommendations = html.querySelector('.product-recommendations');
            if (recommendations && recommendations.innerHTML.trim().length) {
              productRecommendationsSection.innerHTML = recommendations.innerHTML;
            }
          })
          .catch(e => {
            console.error(e);
          });
      });
    </script><script>document.addEventListener('DOMContentLoaded', () => {
        const filterWrapper = document.querySelectorAll('[li-render="filter-wrapper"]');
        const recWrapper = document.querySelectorAll('[li-render="recommendations-wrapper"]')
        const defaultWrapper = document.querySelectorAll('[li-render="default-wrapper"]')
        const searchWrapper = document.querySelectorAll('[li-render="predictive-search-wrapper"]')
        let filterQuery = new URLSearchParams(window.location.search);
        let setEventListeners = true
        const createSearchQuery = (wrapper) => {
          const rType = wrapper.getAttribute('li-render-rt');
          const rLimit = wrapper.getAttribute('li-render-rl');
          const rLimitScope = wrapper.getAttribute('li-render-rls');
          const rOptionsUnavailableProducts = wrapper.getAttribute('li-render-roup');
          const rOptionsFields = wrapper.getAttribute('li-render-rof');
          let searchQuery = new URLSearchParams();
          if (rType) {
            searchQuery.append('resources[type]', rType);
          }
          if (rLimit) {
            searchQuery.append('resources[limit]', rLimit);
          }
          if (rLimitScope) {
            searchQuery.append('resources[limit_scope]', rLimitScope);
          }
          if (rOptionsUnavailableProducts) {
            searchQuery.append(
              'resources[options][unavailable_products]', rOptionsUnavailableProducts);
          }
          if (rOptionsFields) {
            searchQuery.append('resources[options][fields]', rOptionsFields);
          }
          return searchQuery
        }
        const debounce = (callback, wait) => {
          let timeoutId = null;
          return (...args) => {
            window.clearTimeout(timeoutId);
            timeoutId = window.setTimeout(() => {
              callback(...args);
            }, wait);
          };
        }
        setCheckboxFilter = () => {
          document.querySelectorAll('[li-render="filter"]').forEach(element => {
            const param = element.getAttribute('li-render-param-name')
            const value = element.getAttribute('li-render-value')
            const customCheckbox = element.parentElement.querySelector('div')
            if (!param || !value) return
            if (filterQuery.has(param, value)) {
              element.checked = true
              if (customCheckbox) {
                customCheckbox.classList.add('w--redirected-checked')
              }
            } else {
              element.checked = false
              if (customCheckbox) {
                customCheckbox.classList.remove('w--redirected-checked')
              }
            }
          })
        }
        const setPriceFilter = () => {
          if (filterQuery.has('filter.v.price.gte')) {
            document.querySelectorAll('[li-render="price-min"]').forEach(element => {
              element.value = filterQuery.get('filter.v.price.gte')
            })
          }
          if (filterQuery.has('filter.v.price.lte')) {
            document.querySelectorAll('[li-render="price-max"]').forEach(element => {
              element.value = filterQuery.get('filter.v.price.lte')
            })
          }
        }
        const renderSection = async (fetchUrl, wrapper, target = null) => {
          try {
            const response = await fetch(fetchUrl);
            if (!response.ok) {
              throw new Error(
                `Error fetching section, response status: ${response.status}`
              );
            }
            const newHtml = await response.text();
            const parser = new DOMParser();
            const newDocument = parser.parseFromString(newHtml, 'text/html');
            const newElements = target ? newDocument.querySelectorAll(target) : newDocument.querySelectorAll(wrapper);
            if (newElements.length > 0) {
              const currentElements = target ? document.querySelectorAll(target) : document.querySelectorAll(wrapper);
              if (currentElements.length === newElements.length) {
                currentElements.forEach((currentElement, index) => {
                  currentElement.innerHTML = newElements[index].innerHTML;
                });
                initializeFilters();
                setPriceFilter();
                if (target) {
                  // Custom render handling
                  newDocument.querySelectorAll('[li-render-custom-source]').forEach(element => {
                    const value = element.value
                    const customName = element.getAttribute('li-render-custom-source')
                    const customTarget = document.querySelectorAll(`[li-render-custom-target="${customName}"]`)
                    if (!value || customTarget.length === 0) {
                      console.warn('If you want to show the li-render-custom value, you have to add a value to the element and also create a target and mark it with [li-render-custom-target="TARGET_NAME"]. The target name must match the li-render-custom name.')
                      return
                    }
                    customTarget.forEach(target => {
                      target.textContent = value
                    })
                  })
                  // Set active filter states or disabled all inactive filters and show the filter count
                  newDocument.querySelectorAll('[li-render="filter"]').forEach(element => {
                    const param = element.getAttribute('li-render-param-name')
                    const value = element.getAttribute('li-render-value')
                    const countSource = element.getAttribute('li-render-count')
                    const countNumber = parseInt(countSource, 10)
                    if (!param || !value || !countSource) {
                      console.warn(`If you want to show the counts, please add the following attributes to the [li-render="filter"] element: 
                  [li-render-count="{{ filter_value.count }}"], [li-render-value="{{ filter_value.value }}"], [li-render-param-name="{{ filter_value.param_name }}"].`)
                      return
                    }
                    document.querySelectorAll(`[li-render-param-name="${param}"][li-render-value="${value}"]`).forEach(filterElement => {
                      const countTarget = filterElement.parentElement.querySelector('[li-render="count-value"]')
                      /* TODO: Check whether necessary. The idea is to set the checked state on every checkbox if multiple exist */
                      // filterQuery.has(param, value) ? filterElement.checked = true : filterElement.checked = false
                      if (countNumber === 0) {
                        filterElement.classList.add('is-disabled')
                      } else {
                        filterElement.classList.remove('is-disabled')
                      }
                      if (countTarget) countTarget.textContent = countNumber
                    })
                  })
                }
                document.dispatchEvent(new CustomEvent('liquify:sections-rendered', {
                  bubbles: true,
                  cancelable: false,
                  composed: false
                }));
              } else {
                console.warn('Mismatch in element count between current and new content.');
              }
            }
          } catch (error) {
            console.error(error.message);
          }
        };
        searchWrapper.forEach((wrapper) => {
          const input = wrapper.querySelector('[li-render="predictive-search-input"]');
          const sectionId = wrapper.getAttribute('li-render-section-id');
          if (!sectionId) {
            console.warn('Failed to render section because of missing section id')
            return
          }
          const searchQuery = createSearchQuery(wrapper)
          if (input) {
            input.addEventListener(
              'input',
              debounce(() => {
                const searchTerm = input.value.trim();
                let searchUrl = ''
                if (searchQuery.size === 0) {
                  searchUrl = `/search/suggest?q=${searchTerm}&section_id=${sectionId}`
                } else {
                  searchUrl = `/search/suggest?q=${searchTerm}&section_id=${sectionId}&${searchQuery}`
                }
                if (searchTerm) {
                  renderSection(searchUrl, '[li-render="predictive-search-wrapper"]',
                    '[li-render="predictive-search-target"]')
                };
                console.log(searchUrl)
              }, 300)
            );
          }
        });
        const initializeFilters = () => {
          filterWrapper.forEach((wrapper) => {
            const submitButtons = wrapper.querySelectorAll('[li-render="submit-button"]')
            const filterTarget = wrapper.querySelector('[li-render="filter-target"]')
            const getQueryParam = (param = '', value = '', render = false, uniqueValue = false, priceRemove = false) => {
              if (filterQuery.has(param) && uniqueValue === true && priceRemove === false) {
                filterQuery.set(param, value)
              } else if ((filterQuery.has(param, value) && uniqueValue === false) || priceRemove === true) {
                value === '' ? filterQuery.delete(param) : filterQuery.delete(param, value)
              } else {
                filterQuery.append(param, value)
              }
              const completeFilterQuery = filterQuery.size > 0 ? '?' + filterQuery : ''
              const handleTarget = () => {
                history.replaceState(null, '', window.location.pathname + completeFilterQuery);
                if (filterTarget) {
                  renderSection(completeFilterQuery, '[li-render="filter-wrapper"]', '[li-render="filter-target"]');
                } else {
                  renderSection(completeFilterQuery, '[li-render="filter-wrapper"]');
                }
              }
              if (submitButtons.length === 0 || render === true) {
                handleTarget()
                return;
              }
              if (submitButtons.length > 0) {
                submitButtons.forEach(button => {
                  button.addEventListener('click', (event) => {
                    event.preventDefault();
                    handleTarget()
                  });
                })
              }
            };
            if (setEventListeners === false) return
            wrapper
              .querySelectorAll('[li-render="filter"]')
              .forEach((element) => {
                element.addEventListener("change", () => {
                  const param = element.getAttribute('li-render-param-name')
                  const value = element.getAttribute('li-render-value')
                  getQueryParam(param, value);
                });
              });
            wrapper
              .querySelectorAll('[li-render="sort-select"]')
              .forEach((element) => {
                element.addEventListener("change", () => {
                  getQueryParam('sort_by', element.value, true, true);
                });
              });
            wrapper
              .querySelectorAll('[li-render="sort-radio"]')
              .forEach((element) => {
                element.addEventListener("change", () => {
                  const value = element.getAttribute('li-render-value')
                  getQueryParam('sort_by', value, true, true);
                });
              });
            wrapper
              .querySelectorAll('[li-render="filter-remove"]')
              .forEach((element) => {
                element.addEventListener("click", (event) => {
                  const removeFilter = element.getAttribute('li-render-value')
                  renderSection(removeFilter, '[li-render="filter-wrapper"]');
                  history.replaceState(null, '', removeFilter);
                });
              });
            wrapper.querySelectorAll('[li-render="filter-search"]').forEach(element => {
              const form = element.closest('form')
              const searchQuery = createSearchQuery(wrapper)
              let inputValue = element.value
              element.addEventListener('input',
                debounce(() => {
                  inputValue = element.value
                  if (window.location.pathname === '/search') {
                    getQueryParam('q', inputValue, undefined, true);
                  }
                  console.log(inputValue)
                }, 300)
              )
              if (inputValue !== '' && window.location.pathname !== '/search' && form) {
                form.addEventListener('submit', (event) => {
                  event.preventDefault()
                  form.action = `/search?${searchQuery}&q=${inputValue}`
                  form.submit()
                })
              }
            })
            wrapper
              .querySelectorAll('[li-render="clear-all"]')
              .forEach((element) => {
                element.addEventListener('click', (event) => {
                  const value = element.getAttribute('li-render-value')
                  if (!value) {
                    console.warn(`Unable to clear all filters because of one missing attribute.
                Please add the attribute [li-render-value="{{ routes.search_url }}"] on search pages or [li-render-value="{{ collection.url }}"] on collection pages to the [li-render="clear-all"] button`)
                    return
                  }
                  filterQuery = new URLSearchParams()
                  history.replaceState(null, '', window.location.pathname);
                  renderSection(value, '[li-render="filter-wrapper"]')
                });
              });
            wrapper.querySelectorAll('[li-render="price-min"]').forEach(element => {
              element.addEventListener('blur', () => {
                if (element.value.length === 0) {
                  getQueryParam('filter.v.price.gte', element.value, false, true, true);
                  return
                }
                getQueryParam('filter.v.price.gte', element.value, false, true)
              })
            })
            wrapper.querySelectorAll('[li-render="price-max"]').forEach(element => {
              element.addEventListener('blur', () => {
                if (element.value.length === 0) {
                  getQueryParam('filter.v.price.lte', element.value, false, true, true);
                  return
                }
                getQueryParam('filter.v.price.lte', element.value, false, true)
              })
            })
            if (filterTarget) setEventListeners = false
          })
        };
        recWrapper.forEach((wrapper) => {
          const path = wrapper.getAttribute('li-render-path')
          const sectionId = wrapper.getAttribute('li-render-section-id')
          const productId = wrapper.getAttribute('li-render-product-id')
          const limit = wrapper.getAttribute('li-render-limit') || 4;
          const intent = wrapper.getAttribute('li-render-intent') || "related";
          if (!sectionId) {
            console.warn(
              'Unable to render product recommendations because of missing section ID. Please add the attribute li-render-section-id="{{ section.id }}" to the li-render="recommendations-wrapper" element'
            )
            return
          }
          if (!productId) {
            console.warn(
              'Unable to render product recommendations because of missing product ID. Please add the attribute li-render-product-id="{{ product.id }}" to the li-render="recommendations-wrapper" element'
            )
            return
          }
          let recQuery = new URLSearchParams()
          recQuery.append('section_id', sectionId)
          recQuery.append('product_id', productId)
          recQuery.append('limit', limit)
          recQuery.append('intent', intent)
          const fetchUrl = `${path}?${recQuery}`;
          renderSection(fetchUrl, '[li-render="recommendations-wrapper"]');
          console.log(fetchUrl)
        });
        defaultWrapper.forEach(wrapper => {
          const sectionId = wrapper.getAttribute('li-render-section-id')
          const variantId = wrapper.getAttribute('li-render-variant-id')
          const trigger = wrapper.querySelector('[li-render="trigger"]')
          const target = wrapper.querySelector('[li-render="target"]')
          if (!sectionId) {
            console.warn("Failed to render section because of missing section id")
            return
          }
          if (!variantId) {
            console.warn("Failed to render section because of missing variant id")
            return
          }
          if (trigger.hasAttribute('input')) {
            trigger.addEventListener('change', () => {
            })
          }
          const fetchUrl = `${window.location.pathname}?section_id=${sectionId}&variant=${variantId}`
          renderSection(fetchUrl, '[li-render="default-wrapper"]', '[li-render="target"]')
        })
        initializeFilters();
        setPriceFilter();
        setCheckboxFilter();
      });
    </script>
</body>
</html>